# The format version is an indicator of the compatibility of third-party exercises with the
# Rustlings program.
# The format version is not the same as the version of the Rustlings program.
# In case Rustlings makes an unavoidable breaking change to the expected format of third-party
# exercises, you would need to raise this version and adapt to the new format.
# Otherwise, the newest version of the Rustlings program won't be able to run these exercises.
format_version = 1

# Optional multi-line message to be shown to users when just starting with the exercises.
welcome_message = """
'                      __  ___                 
'     _______  _______/ /_/ (_)___  ____ ______
'    / ___/ / / / ___/ __/ / / __ \\/ __ `/ ___/     ~
'   / /  / /_/ (__  ) /_/ / / / / / /_/ (__  )     ___
'  /_/   \\__,_/____/\\__/_/_/_/ /_/\\__, /____/     ['_']  
'                                /____/       /=) zh-CN (=\\  
'                                                 -----
'                                                 || ||
'                                                 ~~ ~~
"""

# Optional multi-line message to be shown to users after finishing all exercises.
final_message = """+----------------------------------------------------+
        ~
      ['_']  
  /=) zh-CN (=\\  >>干得漂亮，休息一会吧~
      -----
      || ||
      ~~ ~~
"""

# Repeat this section for every exercise.
[[exercises]]
# Exercise name which is the exercise file name without the `.rs` extension.
name = "intro1"

# Optional directory name to be provided if you want to organize exercises in directories.
# If `dir` is specified, the exercise path is `exercises/DIR/NAME.rs`
# Otherwise, the path is `exercises/NAME.rs`
dir = "00_intro"

# Rustlings expects the exercise to contain tests and run them.
# You can optionally disable testing by setting `test` to `false` (the default is `true`).
# In that case, the exercise will be considered done when it just successfully compiles.
test = false

# Rustlings will always run Clippy on exercises.
# You can optionally set `strict_clippy` to `true` (the default is `false`) to only consider
# the exercise as done when there are no warnings left.
# strict_clippy = false

# A multi-line hint to be shown to users on request.
hint = """在终端键入`n`并回车进入下一个练习。"""
skip_check_unsolved = true

[[exercises]]
name = "intro2"
dir = "00_intro"
test = false
hint = """提供打印功能的宏是`printline!`吗？看看编译器提示了什么"""

[[exercises]]
name = "variables1"
dir = "01_variables"
test = false
hint = """声明变量并赋值的操作中，是不是少了什么用来绑定值的关键字"""

[[exercises]]
name = "variables2"
dir = "01_variables"
test = false
hint = """编译器的消息表明，Rust无法从代码中推断出变量`x`所具有的类型。
要是在`main`函数的第一行添加类型注解会怎样呢？
如果给`x`赋予一个值又会如何呢？
要是这两件事都做了，又会变成什么样呢？
另外，`x`应该是什么类型呢？
要是`x`和`10`是相同类型会怎样？如果是不同类型又会怎样呢？ """

[[exercises]]
name = "variables3"
dir = "01_variables"
test = false
hint = """你正在试图使用已创建但未赋值的变量？
这类错误在编程语言中是经常出现的(值得庆幸的是，Rust编译器发现了这个错误)。 """

[[exercises]]
name = "variables4"
dir = "01_variables"
test = false
hint = """在Rust中，变量默认是不可变(immutable)的。
但这里我们需要给变量赋另外一个值，即改变这个变量。
所以在声明变量时要在变量名前加上什么关键字使其可变(mutable)呢？ """

[[exercises]]
name = "variables5"
dir = "01_variables"
test = false
hint = """在 `variables4` 中，我们学习了如何使用特定关键字来修改变量可变性。
不过，在这个练习里，那种方法没什么用处。
这是因为这次我们想要给现有的变量名赋予不同的类型。而且有时候可能也会希望重新使用相同的变量名（比如仅仅稍微改变一下变量里面内容的类型等情况）。
为了应对这样的状况，在 Rust 中有 `变量遮蔽(Shadowing)` 这种方法。
变量遮蔽在 The Rust Book 中有详细讲解:
https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#shadowing"""

[[exercises]]
# Exercise name which is the exercise file name without the `.rs` extension.
name = "variables6"
dir = "01_variables"
test = false
hint = """到目前为止，我们已经了解了变量和可变性相关的知识，不过Rust中还存在一种重要的类型叫做常量。
常量始终是不可变的，并且使用 `const` 关键字进行声明。
值得注意的是，常量的类型在代码中总是需要明确地进行声明。
关于变量和常量的区别，在 The Rust Book 中有详细讲解：
https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#constants"""

[[exercises]]
name = "functions1"
dir = "02_functions"
test = false
hint = """在`main`函数内调用了`call_me`函数，然而该函数在代码中并不存在。
而且代码推测这个函数不需要参数，也没有返回值，这和`main`函数挺相似的呢。"""

[[exercises]]
name = "functions2"
dir = "02_functions"
test = false
hint = """在Rust中，函数的签名(用来描述函数输入输出的部分)里类型声明是必需的。
对于`call_me`函数来说，它缺少了什么呢？"""

[[exercises]]
name = "functions3"
dir = "02_functions"
test = false
hint = """函数的声明本身没有问题，不过函数的调用方式似乎存在问题。"""

[[exercises]]
name = "functions4"
dir = "02_functions"
test = false
hint = """错误消息指出在`sale_price`函数中 “->” 之后没有写明返回值的类型。参考一下`is_even`函数吧。"""

[[exercises]]
name = "functions5"
dir = "02_functions"
test = false
hint = """Rust区分表达式和语句。
表达式返回与操作对象对应的值，语句仅返回`()`空空如也。
`square`函数应该返回`i32`，但是却返回了`()`。
仔细看看`square`函数的代码吧。"""

[[exercises]]
name = "if1"
dir = "03_if"
hint = """你也可以用一行代码来实现想要执行的操作哦。
在Rust语言里需要记住以下几点:
- `if` 语句的条件是不需要用圆括号之类的符号括起来的。
- `if` 和 `else` 是表达式。
- 在条件表达式后面通常会跟着 `{}` 代码块。 """

[[exercises]]
name = "if2"
dir = "03_if"
hint = """请考虑`在Rust中每个条件块需要返回 相同类型 的值`这一点来修改代码哦。
关于测试期望的内容，请阅读测试用例中`传入了什么，期待返回什么`。"""

[[exercises]]
name = "if3"
dir = "03_if"
hint = """请考虑`在Rust中每个条件块需要返回 相同类型 的值`这一点来修改代码哦。"""

